#summary How to write XSpec scenarios

=Introduction=

The description of the behaviour of a stylesheet lives within an XSpec document, which should adhere to the [http://code.google.com/p/xspec/source/browse/trunk/xspec.rnc XSpec RELAX NG schema]. All elements are in the `http://www.jenitennison.com/xslt/xspec` namespace.

The document element is a `<description>` element, whose `stylesheet` attribute holds a relative URI pointing to the stylesheet that the XSpec document describes. You can also specify:

 * a `version` attribute that gives the version of the stylesheet the XSpec document describes
 * a `xslt-version` attribute that gives the version of XSLT the stylesheet uses; if you don't specify it, this defaults to 2.0

The `<description>` element contains a number of `<scenario>` elements, each of which describes a particular scenario that's being tested. Each `<scenario>` element has a `label` attribute that describes the scenario in human language. For example:

{{{
<scenario label="when processing a para element">
  ...
</scenario>
}}}

Scenarios fall into three main types:

 * *[#Matching_Scenarios matching scenarios]* describe the result of applying templates to a node in a particular mode (and with particular parameters)
 * *[#Function_Scenarios function scenarios]* describe the results of calling a particular function with particular arguments
 * *[#Named_Scenarios named scenarios]* describe the results of calling a particular named template with particular parameters

= Matching Scenarios =

Matching scenarios hold a `<context>` element that describes a node to apply templates to. The context can be supplied in two main ways:

 * you can point to a node in an existing document by giving the document URI in the `href` attribute and, if you want, selecting a particular node by putting a path in the `select` attribute
 * you can embed XML within the `<context>` element; the content becomes the context node, although you can also select a node within that XML using the `select` attribute

The first method is useful if you already have example XML documents that you want to use as the basis of your testing. For example:

{{{
<scenario label="when processing a para element">
  <context href="source/test.xml" select="/doc/body/p[1]" />
  ...
</scenario>
}}}

The second method is related to the concept of a [http://en.wikipedia.org/wiki/Mock_object mock object]: it is an example of some XML which you have created simply for testing purposes. The XML might not be legal; it only needs to have the attributes or content necessary for the particular behaviour that needs to be tested. For example:

{{{
<scenario label="when processing a para element">
  <context>
    <para>...</para>
  </context>
  ...
</scenario>
}}}

The `<context>` element can also have a `mode` attribute that supplies the mode to apply templates in.

= Function Scenarios =

Function scenarios hold a `<call>` element with a `function` attribute whose content is a qualified name that is the same as the qualified name of the function you want to call. The `<call>` element should hold a number of `<param>` elements, one for each of the arguments to the function.

The `<param>` elements can specify node values in the same way as the `<context>` element gets set (described above), or simply by giving a `select` attribute which holds an XPath that specifies the value. You can specify a `name` or `position` attribute for each of the `<param>` elements; if you don't, the order in which they're specified will determine the order in which they're given in the function call. For example:

{{{
<scenario label="when capitalising a string">
  <call function="eg:capital-case">
    <param select="'an example string'" />
    <param select="true()" />
  </call>
  ...
</scenario>
}}}

will result in the call `eg:capital-case('an example string', false())` as will:

{{{
<scenario label="when capitalising a string">
  <call function="eg:capital-case">
    <param select="true()" position="2" />
    <param select="'an example string'" position="1" />
  </call>
  ...
</scenario>
}}}

= Named Scenarios =

Named template scenarios are similar to function scenarios except that the `<call>` element takes a `template` attribute rather than a `function` attribute, and the `<param>` elements within it must have a `name` attribute that supplies the name of the parameter. These parameters can also have a `tunnel` attribute to indicate a tunnel parameter. For example:

{{{
<scenario label="when creating a table with two columns containing three values">
  <call template="createTable">
    <param name="nodes">
      <value>A</value>
      <value>B</value>
      <value>C</value>
    </param>
    <param name="cols" select="2" />
  </call>
  ...
</scenario>
}}}

In fact, you can use `<param>` in the same way within the `<context>` element in matching scenarios.

= Expectations =

Each scenario can have one or more "expectations": things that should be true of the result of the function or template invocation described by the scenario. Each expectation is specified with an `<expect>` element. The `label` attribute on the `<expect>` element gives a human-readable description of the expectation.

There are two main kinds of expectations:

 * a value that the result should match, which may be
    * an atomic value
    * an XML snippet
 * an arbitrary XPath test that should be true of the result

To specify an atomic value, use the `select` attribute on the `<expect>` element. For example:

{{{
<scenario label="when capitalising a string">
  <call function="eg:capital-case">
    <param select="'an example string'" />
    <param select="true()" />
  </call>
  <expect label="it should capitalise every word in the string" select="'An Example String'" />
</scenario>
}}}

To specify some XML, put it within the `<expect>` element. For example:

{{{
<scenario label="when processing a para element">
  <context>
    <para>...</para>
  </context>
  <expect label="it should produce a p element">
    <p>...</p>
  </expect>
</scenario>
}}} 

One thing to note here is that when comparing the actual result with the expected result, three dots in an element or attribute value within the expected XML means that the values aren't compared. If the actual result is:

{{{
  <p>A sample para</p>
}}}

and the expected result is given as:

{{{
  <p>...</p>
}}}

then these match. If the expected result is:

{{{
  <p>Some other para</p>
}}}

then they don't.

To specify an arbitrary XPath test, use the `test` attribute on `<expect>`. For example:

{{{
<scenario label="when creating a table with two columns containing three values">
  <call template="createTable">
    <param name="nodes">
      <value>A</value>
      <value>B</value>
      <value>C</value>
    </param>
    <param name="cols" select="2" />
  </call>
  <expect label="the resulting table should have two columns"
    test="count(/table/colspec/col) = 2" />
</scenario>
}}}

You can also combine the `test` attribute with the content of the `<expect>` element if you want to just test a portion of the result. For example:

{{{
<scenario label="when creating a table with two columns containing three values">
  <call template="createTable">
    <param name="nodes">
      <value>A</value>
      <value>B</value>
      <value>C</value>
    </param>
    <param name="cols" select="2" />
  </call>
  <expect label="the resulting table should have two columns"
    test="count(/table/colspec/col) = 2" />
  <expect label="the first row should contain the first two values"
    test="/table/tbody/tr[1]">
    <tr>
      <td>A</td><td>B</td>
    </tr>
  </expect>
</scenario>
}}}