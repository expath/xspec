#summary What does produce the compilation?
#labels Phase-Implementation,Featured

=Contents=

<wiki:toc max_depth="1" />

=Introduction=

This page aims to provide an overview of the result of the
compilation of XSpec test suites to either XSLT or XQuery (the
two available implementations for now).  It does so by showing
simple examples and the associated generated stylesheet and
query.

The generated stylesheets and queries are not shown entirely and
the generated code is somewhat cleaned to show only relevant
parts.  In particular, the code generating stuff in the final
report have been removed, exept in the cases specifically used to
show how this is done.  Indentation and comments have been added
too when appropriate.  The root element of the test suites is
never shown neither.

The goal is just to make the compilation phase clearer, mostly
for developing purposes.

=Simple scenario=

==Test suite==
{{{
<t:scenario label="scenario">
   <t:call function="f"/>
   <t:expect label="expectations" test="predicate"/>
</t:scenario>
}}}

==Stylesheet==
{{{
<!-- generated from the scenario element -->
<xsl:template name="x:d4e2">
   <x:call function="f"/>
   <xsl:variable name="impl:actual-result" as="item()*">
      <xsl:sequence select="f()"/>
   </xsl:variable>
   ... generate scenario data in the report ...
   <xsl:call-template name="x:d4e4">
      <xsl:with-param name="x:result" select="$impl:actual-result"/>
   </xsl:call-template>
</xsl:template>

<!-- generated from the expect element -->
<xsl:template name="x:d4e4">
   <xsl:param name="x:result" required="yes"/>
   <!-- expected result (none here) -->
   <xsl:variable name="impl:expected" select="()"/>
   <!-- wrap $t:result into a doc node if node()+ -->
   <xsl:variable name="impl:test-items" as="item()*">
      <xsl:choose>
         <xsl:when test="$x:result instance of node()+">
            <xsl:document>
               <xsl:copy-of select="$x:result"/>
            </xsl:document>
         </xsl:when>
         <xsl:otherwise>
            <xsl:sequence select="$x:result"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>
   <!-- evaluate the predicate with $t:result as context
        node if $t:result is a single node, if not just
        evaluate the predicate -->
   <xsl:variable name="impl:test-result" as="item()*">
      <xsl:choose>
         <xsl:when test="count($impl:test-items) eq 1">
            <xsl:for-each select="$impl:test-items">
               <xsl:sequence select="predicate" version="2"/>
            </xsl:for-each>
         </xsl:when>
         <xsl:otherwise>
            <xsl:sequence select="predicate" version="2"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>
   <!-- did the test pass? -->
   <xsl:variable name="impl:boolean-test" as="xs:boolean"
                 select="$impl:test-result instance of xs:boolean"/>
   <xsl:variable name="impl:successful" as="xs:boolean" select="
       if ( $impl:boolean-test ) then
         $impl:test-result
       else
         test:deep-equal($impl:expected, $impl:test-result, 2)"/>
   ... generate test result in the report ...
</xsl:template>
}}}

==Query==
{{{
(: generated from the scenario element :)
declare function local:d4e2()
{
  ... generate scenario data in the report ...
  let $local:result := f()
    return (
      local:d4e4($local:result)
    )
};

(: generated from the expect element :)
declare function local:d4e4($t:result as item()*)
{
  let $local:expected    :=                  (: expected result (none here) :)
      (  )
  let $local:test-result :=                  (: evaluate the predicate :)
      if ( $t:result instance of node() ) then
        $t:result/( predicate )
      else
        ( predicate )
  let $local:successful  :=                  (: did the test pass?:)
      if ( $local:test-result instance of xs:boolean ) then
        $local:test-result
      else
        test:deep-equal($local:expected, $local:test-result)
    return
      ... generate test result in the report ...
};
}}}

=Variables=

This is not implemented yet, but this is an example of what they
shall look like.

==Test suite==
{{{
<t:scenario label="scenario">
   <t:variable name="var" select="'value'"/>
   ...
   <t:expect .../>
</t:scenario>
}}}

==Stylesheet==
{{{
<!-- generated from the scenario element -->
<xsl:template name="x:d4e2">
   <!-- the generated variable -->
   <xsl:variable name="var" select="'value'"/>
   <xsl:variable name="impl:actual-result" as="item()*">
      ... evaluate the test expression ...
   </xsl:variable>
   ...
   <xsl:call-template name="x:d4e4">
      <xsl:with-param name="x:result" select="$impl:actual-result"/>
   </xsl:call-template>
</xsl:template>

<!-- generated from the expect element -->
<xsl:template name="x:d4e4">
   <xsl:param name="x:result" required="yes"/>
   <!-- the generated variable -->
   <xsl:variable name="var" select="'value'"/>
   <!-- evaluate the expectation -->
   <xsl:variable name="impl:expected" ...>
   <xsl:variable name="impl:test-items" ...>
   <xsl:variable name="impl:test-result" ...>
   ...
</xsl:template>
}}}

==Query==
{{{
(: generated from the scenario element :)
declare function local:d4e2()
{
  ...
  let $var          := 'value'               (: the generated variable :)
  let $local:result := ... evaluate the test expression ...
    return (
      local:d4e4($local:result)
    )
};

(: generated from the expect element :)
declare function local:d4e4($t:result as item()*)
{
  let $var               := 'value'          (: the generated variable :)
  let $local:expected    := ...              (: expected result :)
  let $local:test-result := ...              (: evaluate the expectations :)
  let $local:successful  := ...              (: did the test pass?:)
    return
      ... generate test result in the report ...
};
}}}