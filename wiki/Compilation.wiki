#summary What does produce the compilation?
#labels Phase-Implementation,Featured

=Contents=

<wiki:toc max_depth="1" />

=Introduction=

This page aims to provide an overview of the result of the
compilation of XSpec test suites to either XSLT or XQuery (the
two available implementations for now).  It does so by showing
simple examples and the associated generated stylesheet and
query.

The generated stylesheets and queries are not shown entirely and
the generated code is somewhat cleaned to show only relevant
parts.  In particular, the code generating stuff in the final
report have been removed, exept in the cases specifically used to
show how this is done.  Indentation and comments have been added
too when appropriate.  The root element of the test suites is
never shown neither.

The goal is just to make the compilation phase clearer, mostly
for developing purposes.

=Simple scenario=

==Test suite==
{{{
<t:scenario label="scenario">
   <t:call function="f"/>
   <t:expect label="expectations" test="predicate"/>
</t:scenario>
}}}

==Stylesheet==
{{{
<!-- generated from the scenario element -->
<xsl:template name="x:d4e2">
   <x:call function="f"/>
   <xsl:variable name="impl:actual-result" as="item()*">
      <xsl:sequence select="f()"/>
   </xsl:variable>
   ... generate scenario data in the report ...
   <xsl:call-template name="x:d4e4">
      <xsl:with-param name="x:result" select="$impl:actual-result"/>
   </xsl:call-template>
</xsl:template>

<!-- generated from the expect element -->
<xsl:template name="x:d4e4">
   <xsl:param name="x:result" required="yes"/>
   <!-- expected result (none here) -->
   <xsl:variable name="impl:expected" select="()"/>
   <!-- wrap $t:result into a doc node if node()+ -->
   <xsl:variable name="impl:test-items" as="item()*">
      <xsl:choose>
         <xsl:when test="$x:result instance of node()+">
            <xsl:document>
               <xsl:copy-of select="$x:result"/>
            </xsl:document>
         </xsl:when>
         <xsl:otherwise>
            <xsl:sequence select="$x:result"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>
   <!-- evaluate the predicate with $t:result as context
        node if $t:result is a single node, if not just
        evaluate the predicate -->
   <xsl:variable name="impl:test-result" as="item()*">
      <xsl:choose>
         <xsl:when test="count($impl:test-items) eq 1">
            <xsl:for-each select="$impl:test-items">
               <xsl:sequence select="predicate" version="2"/>
            </xsl:for-each>
         </xsl:when>
         <xsl:otherwise>
            <xsl:sequence select="predicate" version="2"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:variable>
   <!-- did the test pass? -->
   <xsl:variable name="impl:boolean-test" as="xs:boolean"
                 select="$impl:test-result instance of xs:boolean"/>
   <xsl:variable name="impl:successful" as="xs:boolean" select="
       if ( $impl:boolean-test ) then
         $impl:test-result
       else
         test:deep-equal($impl:expected, $impl:test-result, 2)"/>
   ... generate test result in the report ...
</xsl:template>
}}}

==Query==
{{{
(: generated from the scenario element :)
declare function local:d4e2()
{
  ... generate scenario data in the report ...
  let $local:result := f()
    return (
      local:d4e4($local:result)
    )
};

(: generated from the expect element :)
declare function local:d4e4($t:result as item()*)
{
  let $local:expected    :=                  (: expected result (none here) :)
      (  )
  let $local:test-result :=                  (: evaluate the predicate :)
      if ( $t:result instance of node() ) then
        $t:result/( predicate )
      else
        ( predicate )
  let $local:successful  :=                  (: did the test pass?:)
      if ( $local:test-result instance of xs:boolean ) then
        $local:test-result
      else
        test:deep-equal($local:expected, $local:test-result)
    return
      ... generate test result in the report ...
};
}}}

=Variables=

This is not implemented yet, but this is an example of what they
shall look like.

==Test suite==
{{{
<t:scenario label="scenario">
   <t:variable name="var" select="'value'"/>
   ...
   <t:expect .../>
</t:scenario>
}}}

==Stylesheet==
{{{
<!-- generated from the scenario element -->
<xsl:template name="x:d4e2">
   <!-- the generated variable -->
   <xsl:variable name="var" select="'value'"/>
   <xsl:variable name="impl:actual-result" as="item()*">
      ... evaluate the test expression ...
   </xsl:variable>
   ...
   <xsl:call-template name="x:d4e4">
      <xsl:with-param name="x:result" select="$impl:actual-result"/>
   </xsl:call-template>
</xsl:template>

<!-- generated from the expect element -->
<xsl:template name="x:d4e4">
   <xsl:param name="x:result" required="yes"/>
   <!-- the generated variable -->
   <xsl:variable name="var" select="'value'"/>
   <!-- evaluate the expectation -->
   <xsl:variable name="impl:expected" ...>
   <xsl:variable name="impl:test-items" ...>
   <xsl:variable name="impl:test-result" ...>
   ...
</xsl:template>
}}}

==Query==
{{{
(: generated from the scenario element :)
declare function local:d4e2()
{
  ...
  let $var          := 'value'               (: the generated variable :)
  let $local:result := ... evaluate the test expression ...
    return (
      local:d4e4($local:result)
    )
};

(: generated from the expect element :)
declare function local:d4e4($t:result as item()*)
{
  let $var               := 'value'          (: the generated variable :)
  let $local:expected    := ...              (: expected result :)
  let $local:test-result := ...              (: evaluate the expectations :)
  let $local:successful  := ...              (: did the test pass?:)
    return
      ... generate test result in the report ...
};
}}}

=Variable value=

Here is an example of three variables, one using `@select`, one
using content, and one using `@href`..  As with `xsl:variable`,
they must use one and exactly one of them.  The href attribute is
to load a document from a file (relative to the test suite
document).  The resulting variables must be once in the code
generated for the `scenario` element and once in the code
generated for the `expect` element (well, define more precisely
the scope of the variables, I think we should be able to put them
everywhere, and the scope must "natural" when looking at the test
suite definition).

==Test suite==
{{{
<t:variable name="select"  select="'value'"/>
<t:variable name="href"    href="test-data.xml"/>
<t:variable name="content" as="element()">
   <elem/>
</t:variable>
}}}

==Stylesheet==
{{{
<xsl:variable name="select" select="'value'"/>
<xsl:variable name="href"   select="doc('.../test-data.xml')"/>
<xsl:variable name="content" as="element()">
   <elem/>
</xsl:variable>
}}}

==Query==
{{{
let $select := 'value'
let $href   := doc('.../test-data.xml')
let $content as element() := <elem/>
}}}

=Variables scope=

==Test suite==
{{{
<t:scenario label="outer">
   <t:variable name="var-1" ...>
   <t:scenario label="inner">
      <t:variable name="var-2" ...>
      <t:call function="f"/>
      <t:variable name="var-3" ...>
      <t:expect label="expect one" ...>
      <t:variable name="var-4" ...>
      <t:expect label="expect two" ...>
   </t:scenario>
</t:scenario>
}}}

==Stylesheet==
{{{
<!-- generated from the scenario outer -->
<xsl:template name="x:d4e2">
   <!-- the generated variable -->
   <xsl:variable name="var-1" ...>
   ...
</xsl:template>

<!-- generated from the scenario inner -->
<xsl:template name="x:d4e3">
   <!-- note the outer variable is repeated here -->
   <!-- note also $var-3 and $var-4 are not in scope at this point -->
   <xsl:variable name="var-1" ...>
   <xsl:variable name="var-2" ...>
   <xsl:variable name="impl:actual-result" as="item()*">
      <xsl:sequence select="f()"/>
   </xsl:variable>
   ...
   <xsl:call-template name="x:d4e4">
      <xsl:with-param name="x:result" select="$impl:actual-result"/>
   </xsl:call-template>
   <xsl:call-template name="x:d4e5">
      <xsl:with-param name="x:result" select="$impl:actual-result"/>
   </xsl:call-template>
</xsl:template>

<!-- generated from the expect one -->
<xsl:template name="x:d4e4">
   <xsl:param name="x:result" required="yes"/>
   <!-- note $var-1 and $var-2 are repeated here -->
   <!-- note also $var-4 is not in scope at this point -->
   <xsl:variable name="var-1" ...>
   <xsl:variable name="var-2" ...>
   <xsl:variable name="var-3" ...>
   ... evaluate the expectations ...
</xsl:template>

<!-- generated from the expect two -->
<xsl:template name="x:d4e5">
   <xsl:param name="x:result" required="yes"/>
   <!-- note $var-1, $var-2 and $var-3 are repeated here -->
   <xsl:variable name="var-1" ...>
   <xsl:variable name="var-2" ...>
   <xsl:variable name="var-3" ...>
   <xsl:variable name="var-4" ...>
   ... evaluate the expectations ...
</xsl:template>
}}}

==Query==
{{{
(: generated from the scenario outer :)
declare function local:d4e2()
{
  ...
  let $var-1 := ...
  ...
};

(: generated from the scenario inner :)
declare function local:d4e3()
{
  ...
  (: note the outer variable is repeated here :)
  (: note also $var-3 and $var-4 are not in scope at this point :)
  let $var-1        := ...
  let $var-2        := ...
  let $local:result := f()
    return (
      local:d4e4($local:result),
      local:d4e5($local:result)
    )
};

(: generated from the expect one :)
declare function local:d4e4($t:result as item()*)
{
  (: note $var-1 and $var-2 are repeated here :)
  (: note also $var-4 is not in scope at this point :)
  let $var-1 := ...
  let $var-2 := ...
  let $var-3 := ...
  ...evaluate the expectations ...
};

(: generated from the expect two :)
declare function local:d4e5($t:result as item()*)
{
  (: note $var-1, $var-2 and $var-3 are repeated here :)
  let $var-1 := ...
  let $var-2 := ...
  let $var-3 := ...
  let $var-4 := ...
  ...evaluate the expectations ...
};
}}}